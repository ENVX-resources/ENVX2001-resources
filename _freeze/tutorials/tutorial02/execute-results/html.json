{
  "hash": "6252b256e93fb48ff71915384d8ef8f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tutorial 02\"\n# reviewed-by:\n---\n\n## Welcome ðŸ‘‹ {.unnumbered style=\"color:blue;\"}\n\n**Welcome to Tutorial 2**. In this tutorial we will show you how to:\n\n1.  Take a random sample from a *finite* population; and\n2.  take a random sample from an *infinite* population.\n\n## Getting started\n\n::: column-margin\nIn some instances you will see notes like this one in the margin, which often contain useful tips or reminders.\n:::\n\n- These tutorials are designed to be comprehensive yet accessible. I recommend following along and grasping the statistical concepts as much as you can. \n- You will need to **create your own Quarto (recommended) or R Markdown  document** to complete the exercises. In RStudio, go to \n  - `File -> New File -> Quarto Document...` or \n  - `File -> New File -> R Markdown...` and follow the intuitive prompts.\n- **For those of you who are interested in furthering your data science skills and are keen to learn more**, I have included *optional* sections. These techniques are *not* necessary for you to get through ENVX2001 -- **we do *not* cover code in the exams**. Nevertheless these skills come handy in report writing and data analysis and can be a great addition to your projects.\n- If you have any suggestions for improvement, please let me know! Send me an email (you can find my details on Canvas).\n\n# Sampling finite populations\n\nThere are 2 types of populations from which we may wish to take a random sample; finite and infinite populations.\n\n- **Finite populations** are made of discrete objects like households, people, farms etc. \n- **Infinite populations** are continuous, such as soil, water in a stream.\n\n## Finite populations\n\nImagine a hypothetical situation where we know there are 100 farms in a catchment, and we wish to survey 10 of them about their management practices. \nTo ensure *unbiased* results, the 10 farms should be randomly selected. \n\n**R can do this for us quite easily.**\n\nBelow is the full code to randomly select 10 farms from the 100 in the catchment. We will break it down step by step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1038)\nfarms <- 1:100\nsample(x = farms, size = 10)\n```\n:::\n\n\n### Random, but reproducible\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1038)\n```\n:::\n\n\nThe `set.seed()` function is used to \"fix the [seed](https://en.wikipedia.org/wiki/Random_seed)\" of the random number generator. This is useful when you want to ensure that the random numbers generated are the same each time you run the code, which is useful for reproducibility. We don't want to randomly select 10 farms, and then run the code again and get a different set of 10 farms!\n\nThe number in the brackets can be any number you choose[^1].\n\n[^1]: It is good practice to be as unbiased as possible when picking a number for `set.seed()`. A good choice is the 4 digits for the current time of the day.\n\n### Identifying the population\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfarms <- 1:100\n```\n:::\n\n\nIf there are 100 farms, then we need to be able to select *from* them. This ensures that each farm is unique so that we can perform random sampling without replacement (i.e. we should not be sampling the same farm twice).\n\nThe colon operator (`:`) creates a sequence of numbers from the first number to the second number. For 100 farms we can create a sequence of numbers from 1 to 100 easily using this operator, and assign it to the object `farms`.\n\n::: column-margin\nUsing `:` is arguably much easier than typing out all the numbers from 1 to 100.\n:::\n\n### Simple random sampling\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsites <- sample(x = farms, size = 10)\n```\n:::\n\n\nThe `sample()` function is a `base` R function -- part of the core R language -- and is used to take a random sample of a specified size from a set of values. \n\n::: column-margin\nNotice that no result is printed to the console when you assign (`<-`) something to and object like `sites`. This is because R is not being asked to print anything, and so unless the function itself prints something, nothing will be presented to you. You can print the result by typing `sites` again in a new line, which instructs R to print the value of `sites`.\n:::\n\nTo use the `sample()` function, you need to specify the following arguments:\n\n- `x`: the set of values from which to sample. In this case, the set of farms.\n- `size`: the number of values to sample. In this case, 10 farms.\n\nThe `sample()` function returns a vector of the randomly selected farms, which we have assigned to the object `sites`.\n\nWe now have our random sample of 10 farms from the 100 in the catchment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsites\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 92 27 78 54 48 44 61 66  4 83\n```\n\n\n:::\n:::\n\n\n::: column-margin\nIf you have set the same seed as we have, you should get the same results, which makes your experimental design reproducible.\n:::\n\n## Bonus\n\nA tidyverse approach to the same problem would be to use the `dplyr` package to create a sequence of numbers from 1 to 100, and then use the `sample_n()` function from the `dplyr` package to take a random sample of 10 farms from the 100 in the catchment.\n\nThe action can be performed using pipes (`|>`) to pass the result of one function to the next function, which makes the code easier to read and understand (this is an opinion shared by many).\n\n\n::: panel-tabset\n\n## pipe approach\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nsites <-\n    tibble(farm = 1:100) |> # create a tibble of 100 farms, and...\n    # ...pass it to the next function:\n    sample_n(10) # take a random sample of 10 farms\n```\n:::\n\n\n## Nested approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nsites <- sample_n(tibble(farm = 1:100), 10)\n```\n:::\n\n\n## Stepped approach\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nfarms <- tibble(farm = 1:100)\nsites <- sample_n(farms, 10)\n```\n:::\n\n\n:::\n\n::: column-margin\nPiping is a powerful feature of the tidyverse in R and is common in other programming languages. Here, the `|>` operator is used to pass the result of the `tibble()` function to the `sample_n()` function.\n\nWithout piping, we would either have to nest the functions, or assign the result of the first function to an object and then pass that object in a stepped approach, which generates redundant \"intermediate\" objects before the final result is obtained.\n:::\n\nThe `tibble()` function is used to create a tibble, which is a modern version of a data frame. The `sample_n()` function is used to take a random sample of a specified size from a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsites\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 Ã— 1\n    farm\n   <int>\n 1    14\n 2    41\n 3    96\n 4    73\n 5    25\n 6    88\n 7    40\n 8    32\n 9    39\n10    21\n```\n\n\n:::\n:::\n\n\nUnlike `sample()`, `sample_n()` returns a tibble object which shows data in a column rather than row. It may look clutered with a single variable but it is useful for working with data in the tidyverse, especially when you have multiple variables.\n\n## Practice\n\nUse this section to practice taking random samples from finite populations. Code is provided, but hidden by default for you to make comparisons with your own. Click on the \"Show the code\" button to reveal the code.\n\n1. **Create a random sample of 15 cats from a population of 300 cats.**\n\n::: panel-tabset\n\n## `base` R\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1202)\ncats <- 1:300\nsubjects <- sample(x = cats, size = 15)\n```\n:::\n\n\n## `dplyr` approach\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1202)\nsubjects <-\n    tibble(cat = 1:300) |>\n    sample_n(15)\n```\n:::\n\n\n:::\n\n2. **Create a random sample of 20 trees from a population of 500 trees.**\n\n::: panel-tabset\n\n## `base` R\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1204)\ntrees <- 1:500\nsubjects <- sample(x = trees, size = 20)\n```\n:::\n\n\n## `dplyr` approach\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1204)\nsubjects <-\n    tibble(tree = 1:500) |>\n    sample_n(20)\n```\n:::\n\n\n:::\n\n---\n\n# Sampling infinite populations\n\nWith infinite populations, we deal with continuous variables which the function `sample()` cannot handle as it is designed to work with discrete variables only (whole numbers).\n\n\n### Uniform distribution\n\nImagine we are interested in estimating the mean of a measurement, spatially, across a study area. In this case we need to randomly choose a spatial location which is defined by a spatial coordinate, x and y, and the chance of choosing any location is equal. This is a **uniform distribution**.\n\nAssuming a *hypothetical* study site 100m wide and 100m long where we wish to choose 10 random locations, then we may use the technique below to randomly select 10 locations based on x and y coordinates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1209)\nxcoord <- runif(n = 10, min = 0, max = 100)\nycoord <- runif(n = 10, min = 0, max = 100)\n\nsites_xy <- data.frame(xcoord, ycoord)\n```\n:::\n\n\nThe `runif` function generates random numbers from a uniform distribution, which means that **each number is equally likely to be chosen**. \n\nThe 3 main arguments (inputs) are:\n\n1. `n`: the number of samples\n2. `min`: the minimum value we want in our random numbers\n3. `max`: the maximum value we want in our random numbers \n\n::: column-margin\n\nUse `?runif` to learn more about the `runif()` function.\n\n:::\n\nAs we can see, with two variables (x and y) we now use a data frame to store the information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsites_xy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     xcoord    ycoord\n1  29.14598  5.810736\n2  48.35873 86.962687\n3  99.50902 60.200064\n4  17.75811 83.790473\n5  24.95613 81.485062\n6  20.90561 48.077787\n7  91.04788  6.096274\n8  30.24953  9.560046\n9  83.37310 36.851027\n10 85.06082 80.864236\n```\n\n\n:::\n:::\n\n\n### Exploring the data frame\n\nViewing the data frame can eventually become clunky, and this is even more so when we have more than 2 variables. Use the `head()` or `str()` functions to view the first few rows or the structure of the data frame, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(sites_xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    xcoord    ycoord\n1 29.14598  5.810736\n2 48.35873 86.962687\n3 99.50902 60.200064\n4 17.75811 83.790473\n5 24.95613 81.485062\n6 20.90561 48.077787\n```\n\n\n:::\n:::\n\n\nUsing `head()` shortens the output to the first few rows, which helps a lot when the data frame is large (you don't want to see all the rows at once since the maximum number of rows that can be displayed is 1000).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sites_xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t10 obs. of  2 variables:\n $ xcoord: num  29.1 48.4 99.5 17.8 25 ...\n $ ycoord: num  5.81 86.96 60.2 83.79 81.49 ...\n```\n\n\n:::\n:::\n\n\nThe `str()` function provides a concise summary of the structure of the data frame. It tells us the number of observations and variables, and the type of each variable. This function is probably the most used exploratory function in R.\n\n**Bonus**: The `glimpse()` function from the `dplyr` package is a more modern and user-friendly version of `str()`, and works with both data frames and tibbles. It is especially useful when working with large data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(sites_xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 10\nColumns: 2\n$ xcoord <dbl> 29.14598, 48.35873, 99.50902, 17.75811, 24.95613, 20.90561, 91.â€¦\n$ ycoord <dbl> 5.810736, 86.962687, 60.200064, 83.790473, 81.485062, 48.077787â€¦\n```\n\n\n:::\n:::\n\n\n::: column-margin\n\nNotice the `::` operator in the `glimpse()` function. This is used to access functions from a package without loading the entire package. We basically interpret this as: \"use the `glimpse()` function from the `dplyr` package.\"\nNote that the package must be installed for this to work and you also need to know in advance that the function `glimpse()` is available in the package `dplyr`.\n:::\n\n### Visualising the data\n\nAfter generating the random points, it is always a good idea to visualise them to see if there are issues with the random points. This is especially important when working with spatial data -- in rare cases, the random points may cluster in one area, which is not ideal for a random sample.\n\nWe can use the `plot()` function to visualise the points, or we can use the `ggplot2` package. With enough effort, both methods can produce the same plot, but `ggplot2` is more flexible as it follows the grammar of graphics[^gog]. My recommendation is that you learn `ggplot2` as it is more powerful and flexible. **A good idea in this case is to plot in base R first, and then asking GenAI to plot the same plot using `ggplot2`.**\n\n[^gog]: The [grammar of graphics](https://vita.had.co.nz/papers/layered-grammar.html) is a system for understanding and building graphs by combining components, such as data, scales, and layers, in a consistent and structured way.\n\n::: panel-tabset\n\n## Base R plot\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sites_xy,\n    pch = 19,\n    col = \"blue\",\n    main = \"Random points\",\n    xlab = \"X coordinate\",\n    ylab = \"Y coordinate\"\n)\n```\n\n::: {.cell-output-display}\n![](tutorial02_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n## `ggplot2`\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(\n    data = sites_xy,\n    aes(x = xcoord, y = ycoord)\n) +\n    geom_point() +\n    labs(\n        title = \"Random points\",\n        x = \"X coordinate\",\n        y = \"Y coordinate\"\n    ) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](tutorial02_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n:::\n\nClearly, one issue is that **not all study areas are rectangles**! Rather, they are quite often irregular. This artificial dataset is just to illustrate the **concept** of sampling infinitely, rather than be practically useful. The analysis of spatial data is not in the scope of this unit.\n\n## Practice\n\nUse this section to practice taking random samples from infinite populations. Code is provided, but hidden by default for you to make comparisons with your own. Click on the \"Show the code\" button to reveal the code.\n\n1. Generate 20 random points within a 100m x 100m study area.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1242)\nxcoord <- runif(n = 20, min = 0, max = 100)\nycoord <- runif(n = 20, min = 0, max = 100)\nsites <- data.frame(xcoord, ycoord)\n```\n:::\n\n\n\n2. Now this combines `sample()` and `runif()` functions. Use `runif()` to generate 100 data points between 10 and 20, and then use `sample()` to sample 20 of these points.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1242)\ndata <- runif(n = 100, min = 10, max = 20)\nsampled_data <- sample(data, size = 20)\n```\n:::\n\n\n3. Use `ggplot2` to plot a histogram of the sampled data generated in the previous step.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nggplot(\n    data = data.frame(data = sampled_data),\n    aes(x = data)\n) +\n    geom_histogram(\n        binwidth = 0.5,\n        color = \"black\"\n    ) +\n    labs(\n        title = \"Histogram of sampled data\",\n        x = \"Value\",\n        y = \"Frequency\"\n    ) +\n    theme_bw()\n```\n:::\n\n\n\n# Done!\n\n### Thanks! {-}\n\nThis is the end of the tutorial. \n\n::: column-margin\nIf you have any questions or suggestions, let me know during the lectures or via email. You know where to find me!\n:::\n",
    "supporting": [
      "tutorial02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}